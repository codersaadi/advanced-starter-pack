// @repo/i18n/_internal/generate
import fs from 'node:fs/promises';
import path from 'node:path';
import { glob } from 'glob'; // pnpm add -D glob
import { fallbackLng } from '../settings';
export const localesDir = path.resolve(
  `${process.cwd()}/_internal/`,
  '../../../apps/web/public/locales'
);

const outputDir = path.resolve(process.cwd(), './types'); // Adjust if script is in packages/i18n/scripts
const outputFile = path.join(outputDir, 'generated.d.ts');

// Get all namespace JSON files for a given language (e.g., 'en')
// This helps define the structure and keys.
// Assumes 'en' has all possible keys and namespaces.
// For a more robust solution, you'd merge structures from all languages.
async function getBaseStructure(baseLang = fallbackLng) {
  const langPath = path.join(localesDir, baseLang);
  const namespaceFiles = glob.sync('*.json', { cwd: langPath });
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  const structure: { [key: string]: any } = {};

  for (const nsFile of namespaceFiles) {
    const nsName = path.basename(nsFile, '.json');
    const content = await fs.readFile(path.join(langPath, nsFile), 'utf-8');
    structure[nsName] = JSON.parse(content);
  }
  return structure;
}

// biome-ignore lint/suspicious/noExplicitAny: <explanation>
function generateTypeFromObject(obj: { [x: string]: any }, indentLevel = 1) {
  let typeString = '{\n';
  const indent = '  '.repeat(indentLevel);
  const nextIndent = '  '.repeat(indentLevel + 1);

  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const value = obj[key];
      const safeKey =
        key.includes('-') ||
        key.includes('.') ||
        // biome-ignore lint/performance/useTopLevelRegex: <explanation>
        !/^[a-zA-Z$_][a-zA-Z0-9$_]*$/.test(key)
          ? `"${key}"` // Quote keys with special chars or that are not valid identifiers
          : key;

      typeString += `${indent}${safeKey}: `;
      if (typeof value === 'string') {
        // Could try to infer interpolation args here for more advanced types
        // For "Hello {{name}}", type could be `(args: { name: string | number }) => string;`
        // But for simplicity, we'll stick to `string`.
        typeString += 'string;\n';
      } else if (
        typeof value === 'object' &&
        value !== null &&
        !Array.isArray(value)
      ) {
        typeString += `${generateTypeFromObject(value, indentLevel + 1)}${indent};\n`;
      } else {
        typeString +=
          'any; // Or handle arrays, numbers, booleans explicitly\n';
      }
    }
  }
  typeString += `${'  '.repeat(indentLevel - 1)}}`;
  return typeString;
}

async function main() {
  console.log('Generating i18n types...');
  const baseStructure = await getBaseStructure(fallbackLng); // Or merge structures from all languages

  let outputContent = '// THIS FILE IS AUTOGENERATED. DO NOT EDIT MANUALLY.\n';
  outputContent += '// Run the generation script to regenerate.\n\n';

  // Generate individual namespace interfaces (optional but good for clarity)
  // biome-ignore lint/nursery/useGuardForIn: <explanation>
  for (const namespace in baseStructure) {
    outputContent += `export interface ${namespace.charAt(0).toUpperCase() + namespace.slice(1)} ${generateTypeFromObject(baseStructure[namespace])}\n\n`;
  }

  outputContent += 'export interface Resources {\n';
  // biome-ignore lint/nursery/useGuardForIn: <explanation>
  for (const namespace in baseStructure) {
    const interfaceName =
      namespace.charAt(0).toUpperCase() + namespace.slice(1);
    outputContent += `  ${namespace.includes('-') ? `"${namespace}"` : namespace}: ${interfaceName};\n`;
  }
  outputContent += '}\n\n';

  // You might want to generate other helper types here too, like a union of all keys
  // outputContent += `export type DefaultNamespace = "common"; // Or infer from settings\n`;

  await fs.mkdir(outputDir, { recursive: true });
  await fs.writeFile(outputFile, outputContent, 'utf-8');
  console.log(`Types generated successfully at ${outputFile}`);
}

main().catch(console.error);
